using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ArcaneWorld.Generators;

[Generator]
public class LogFieldGenerator : IIncrementalGenerator {

    private const string LogAttributeName = "CakeToolset.Attribute.LogAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // 查找所有带有 LogAttribute 的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsClassOrStructWithAttribute(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
            )
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc)
        );
    }

    private static bool IsClassOrStructWithAttribute(SyntaxNode node) {
        if (node is not TypeDeclarationSyntax typeDecl) {
            return false;
        }

        // 检查是否有属性
        return typeDecl.AttributeLists.Count > 0;
    }

    private static ClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context) {
        if (context.Node is not TypeDeclarationSyntax typeDeclaration) {
            return null;
        }

        var semanticModel = context.SemanticModel;
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol == null) {
            return null;
        }

        // 检查是否有 LogAttribute
        bool hasLogAttribute = typeSymbol.GetAttributes()
            .Any(attr => {
                var attrClass = attr.AttributeClass;
                if (attrClass == null) {
                    return false;
                }
                return attrClass.ToDisplayString() == LogAttributeName ||
                       attrClass.Name == "LogAttribute" ||
                       attrClass.Name == "Log";
            });

        if (!hasLogAttribute) {
            return null;
        }

        // 检查是否已经有 log 字段或属性
        bool hasLogger = typeSymbol.GetMembers()
            .Any(m => m.Name == "log" || m.Name == "Log");

        if (hasLogger) {
            // 如果已经有 Logger，则不生成
            return null;
        }

        var namespaceName = GetNamespace(typeSymbol);
        var accessibility = typeSymbol.DeclaredAccessibility.ToString().ToLower();

        return new ClassInfo(
            namespaceName,
            typeSymbol.Name,
            typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            accessibility,
            typeDeclaration is ClassDeclarationSyntax
        );
    }

    private static string GetNamespace(INamedTypeSymbol symbol) {
        if (symbol.ContainingNamespace.IsGlobalNamespace) {
            return string.Empty;
        }

        var parts = new List<string>();
        var ns = symbol.ContainingNamespace;
        while (ns != null && !ns.IsGlobalNamespace) {
            parts.Insert(0, ns.Name);
            ns = ns.ContainingNamespace;
        }

        return string.Join(".", parts);
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassInfo> classes,
        SourceProductionContext context
    ) {
        if (classes.IsEmpty) {
            return;
        }

        foreach (var classInfo in classes) {
            var source = GenerateLoggerField(classInfo);
            var fileName = $"{classInfo.FullTypeName.Replace("global::", "").Replace(".", "_")}_Logger.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateLoggerField(ClassInfo classInfo) {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(classInfo.Namespace)) {
            sb.AppendLine($"namespace {classInfo.Namespace};");
            sb.AppendLine();
        }

        var typeKeyword = classInfo.IsClass ? "class" : "struct";
        sb.AppendLine($"partial {typeKeyword} {classInfo.TypeName} {{");
        sb.AppendLine();
        sb.AppendLine($"    private static readonly CommonUtil.Log.ILog log = CakeToolset.Log.LogManager.GetLogger(nameof({classInfo.TypeName}));");
        sb.AppendLine();
        sb.AppendLine("}");

        return sb.ToString();
    }

    private record ClassInfo(
        string Namespace,
        string TypeName,
        string FullTypeName,
        string Accessibility,
        bool IsClass
    );

}

