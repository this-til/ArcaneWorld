using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ArcaneWorld.Generators;

[Generator]
public class ReadOnlyPropertyGenerator : IIncrementalGenerator {

    private const string ReadOnlyPropertyAttributeName = "CakeToolset.Attribute.ReadOnlyPropertyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // 查找所有包含带有 ReadOnlyPropertyAttribute 属性的类
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsClassWithReadOnlyProperty(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx)
            )
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc)
        );
    }

    private static bool IsClassWithReadOnlyProperty(SyntaxNode node) {
        if (node is not ClassDeclarationSyntax classDecl) {
            return false;
        }

        // 检查类中是否有带 ReadOnlyPropertyAttribute 的属性
        return classDecl.Members
            .OfType<PropertyDeclarationSyntax>()
            .Any(prop => prop.AttributeLists.Count > 0);
    }

    private static ClassWithReadOnlyPropertiesInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context) {
        if (context.Node is not ClassDeclarationSyntax classDeclaration) {
            return null;
        }

        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol == null) {
            return null;
        }

        var readOnlyProperties = new List<string>();

        // 遍历类的所有属性
        foreach (var member in classSymbol.GetMembers()) {
            if (member is IPropertySymbol propertySymbol) {
                // 检查属性是否有 ReadOnlyPropertyAttribute
                bool hasReadOnlyAttribute = propertySymbol.GetAttributes()
                    .Any(attr => {
                        var attrClass = attr.AttributeClass;
                        if (attrClass == null) {
                            return false;
                        }
                        return attrClass.ToDisplayString() == ReadOnlyPropertyAttributeName ||
                               attrClass.Name == "ReadOnlyPropertyAttribute" ||
                               attrClass.Name == "ReadOnlyProperty";
                    });

                if (hasReadOnlyAttribute) {
                    readOnlyProperties.Add(propertySymbol.Name);
                }
            }
        }

        if (readOnlyProperties.Count == 0) {
            return null;
        }

        // 检查是否已经有 _ValidateProperty 方法
        bool hasValidatePropertyMethod = classSymbol.GetMembers("_ValidateProperty").Any();

        var namespaceName = GetNamespace(classSymbol);

        return new ClassWithReadOnlyPropertiesInfo(
            namespaceName,
            classSymbol.Name,
            classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            readOnlyProperties,
            hasValidatePropertyMethod
        );
    }

    private static string GetNamespace(INamedTypeSymbol symbol) {
        if (symbol.ContainingNamespace.IsGlobalNamespace) {
            return string.Empty;
        }

        var parts = new List<string>();
        var ns = symbol.ContainingNamespace;
        while (ns != null && !ns.IsGlobalNamespace) {
            parts.Insert(0, ns.Name);
            ns = ns.ContainingNamespace;
        }

        return string.Join(".", parts);
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassWithReadOnlyPropertiesInfo> classes,
        SourceProductionContext context
    ) {
        if (classes.IsEmpty) {
            return;
        }

        foreach (var classInfo in classes) {
            var source = GenerateReadOnlyPropertyCode(classInfo);
            var fileName = $"{classInfo.FullTypeName.Replace("global::", "").Replace(".", "_")}_ReadOnlyProperties.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateReadOnlyPropertyCode(ClassWithReadOnlyPropertiesInfo classInfo) {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Godot;");
        sb.AppendLine("using Godot.Collections;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(classInfo.Namespace)) {
            sb.AppendLine($"namespace {classInfo.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {classInfo.TypeName} {{");
        sb.AppendLine();

        // 生成只读属性名称的静态字段
        sb.AppendLine("    private static readonly System.Collections.Generic.HashSet<StringName> readOnlyPropertyNames = [");
        foreach (var propertyName in classInfo.ReadOnlyProperties) {
            sb.AppendLine($"        PropertyName.{propertyName},");
        }
        sb.AppendLine("    ];");
        sb.AppendLine();

        // 如果类中没有 _ValidateProperty 方法，则生成一个
        if (!classInfo.HasValidatePropertyMethod) {
            sb.AppendLine("    public override void _ValidateProperty(Dictionary property) {");
            sb.AppendLine("        if (readOnlyPropertyNames.Contains(property[\"name\"].AsStringName())) {");
            sb.AppendLine("            property[\"usage\"] = (int)(PropertyUsageFlags.Default | PropertyUsageFlags.ReadOnly);");
            sb.AppendLine("        }");
            sb.AppendLine("        base._ValidateProperty(property);");
            sb.AppendLine("    }");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private record ClassWithReadOnlyPropertiesInfo(
        string Namespace,
        string TypeName,
        string FullTypeName,
        List<string> ReadOnlyProperties,
        bool HasValidatePropertyMethod
    );
}
